![image](https://github.com/user-attachments/assets/0be3eba7-ede4-4ebd-bfb5-38be588dd4c6)# 多表关系
* 一对多(多对一)
* 多对多
* 一对一

## 一对多(多对一)
* 案例: 部门 与 员工的关系
* 关系:一个部门对应多个员工,一个员工对应一个部门
* 实现:**在多的一方建立外键，指向一的一方的主键**,即在**员工里建立外键**
![image](https://github.com/user-attachments/assets/522d89cb-228a-4a4b-85bf-f3fc7ad136e6)




## 多对多
* 案例: 学生 与 课程的关系
* 关系:一个学生可以选修多门课程，一门课程也可以供多个学生选择
* 实现: **建立第三张中间表，中间表至少包含两个外键，分别关联两方主键**
![image](https://github.com/user-attachments/assets/7f29aafc-b2a6-45b3-bf7f-c6be1a830841)

例如：
```SQL
create table student(

   id int auto_increment primary key comment '主键ID',

   name varchar(10) comment '姓名',

   no varchar(10) comment '学号'

)comment ' 学生表';



insert into student values (null,'黛绮丝','2000100101'),(null,'谢逊','2000100102'),(null,'殷天正','2000100103'),(null,'韦一笑','2000100104');



create table course(

   id int auto_increment primary key comment '主键ID',

   name varchar(10) comment '课程名称'

)comment '课程表';



insert into course values (null,'Java'),(null,'PHP'),(null,'Mysql'),(null,'Hadoop');





create table student_course(

   id int auto_increment comment '主键' primary key,

   studentid int not null comment '学生ID',

   courseid int not null comment '课程ID',

   constraint fk_courseid foreign key (courseid) references course(id),

   constraint fk_studentid foreign key (studentid) references student(id)

)comment '学生课程中间表';



insert into student_course values (null,1,1),(null,1,2),(null,1,3),(null,2,3),(null,3,4);
```
![image](https://github.com/user-attachments/assets/eeaadb70-fac7-4863-a4c6-800f32cbc578)

![image](https://github.com/user-attachments/assets/cebc0691-97bf-4b8a-a827-d1dd2955f57f)


## 一对一
* 案例: 用户 与 用户详情的关系
* 关系:一对一关系，多用于单表拆分，将一张表的基础字段放在一张表中，其他详情字段放在另一张表中，以提升操作效率
* 实现:**在任意一方加入外键，关联另外一方的主键，并且设置外键为唯一的(UNIQUE)**
![image](https://github.com/user-attachments/assets/c7b9f6ac-62d3-43d5-bfe7-4b45418f2cd0)

* 例如：
```SQL
create  table tb_user(
    id int auto_increment primary key COMMENT '主键ID',
    name varchar(10) COMMENT '姓名',
    age int COMMENT '年龄',
    gender char(1) COMMENT '1:男， 2：女',
    phone char(11) COMMENT '手机号'
)comment '用户基本信息表';

create  table tb_user_edu(
    id int auto_increment primary key COMMENT '主键ID',
    degree varchar(20) COMMENT '学历',
    major varchar(50) COMMENT '专业',
    primaryschool varchar(50) COMMENT '小学',
    middleschool varchar(50) COMMENT '中学',
    university varchar(50) COMMENT '大学',
    userid int unique COMMENT '用户ID', --userid作为唯一外键
    constraint fk_userid foreign key  (userid) references  tb_user(id)
)comment '用户教育信息表';

insert into tb_user(id,name,age,gender,phone) values
(null,'黄渤',45,'1','18800001111'),
(null,'冰冰',35,'2','18800002222'),
(null,'码云',55,'1','18800008888' ),
(null,'李彦宏',50,'1','18800009999');

insert into tb_user_edu(id, degree, major, primaryschool, middleschool, university, userid) values
(null,'本科','舞蹈','静安区第一小学','静安区第一中学','北京舞蹈学院',1),
(null,'硕士','表演','朝阳区第一小学','朝阳区第一中学','北京电影学院',2),
(null,'本科','英语','杭州市第一小学','杭州市第一中学','杭州师范大学',3),
(null,'本科','应用数学','阳泉第一小学','阳泉区第一中学','清华大学',4);
```
![image](https://github.com/user-attachments/assets/4366ef63-7647-4ee8-8569-44b6c89dafc8)
![image](https://github.com/user-attachments/assets/550c2212-7b93-4d99-9479-d48bf24c6d1f)

## 多表查询
```sql
create table dept(
    id int primary key auto_increment,
    name varchar(10)
);

insert into dept values
     (null, '研发部'),
     (null, '市场部'),
     (null, '财务部'),
     (null, '销售部'),
     (null, '总经办'),
     (null, '人事部');

create table emp(
    id int primary key auto_increment,
    name varchar(10),
    age int,
    job varchar(10),
    salary int,
    entrydate date,
    managerid int,
    dept_id int,
    constraint fk_dept foreign key (dept_id) references dept(id)
);

insert into emp values
    (null, '金庸', 66, '总裁', 20000, '2000-01-01', null, 5),
    (null, '张无忌', 20, '项目经理', 12500, '2005-12-05', 1, 1),
    (null, '杨逍', 33, '开发', 8400, '2000-11-03', 2, 1),
    (null, '韦一笑', 48, '开发', 11000, '2002-02-05', 2, 1),
    (null, '常遇春', 43, '开发', 10500, '2004-09-07', 3, 1),
    (null, '小昭', 19, '程序员鼓励师', 6600, '2004-10-12', 2, 1),
    (null, '灭绝', 60, '财务总监', 8500, '2002-09-12', 1, 3),
    (null, '周芷若', 19, '会计', 4800, '2006-06-02', 7, 3),
    (null, '丁敏君', 23, '出纳', 5250, '2009-05-13', 7, 3),
    (null, '赵敏', 20, '市场部总监', 12500, '2004-10-12', 1, 2),
    (null, '鹿杖客', 56, '职员', 3750, '2006-10-03', 10, 2),
    (null, '鹤笔翁', 19, '职员', 3750, '2007-05-09', 10, 2),
    (null, '方东白', 19, '职员', 5500, '2009-02-12', 10, 2),
    (null, '张三丰', 88, '销售总监', 14000, '2004-10-12', 1, 4),
    (null, '俞莲舟', 38, '销售', 4600, '2004-10-12', 14, 4),
    (null, '宋远桥', 40, '销售', 4600, '2004-10-12', 14, 4),
    (null, '陈友谅', 42, null, 2000, '2011-10-12', 1, null);

create table salgrade(
    grade int,
    losal int,
    hisal int
);

insert into salgrade
values (1, 0, 3000),
       (2, 3001, 5000),
       (3, 5001, 8000),
       (4, 8001, 10000),
       (5, 10001, 15000),
       (6, 15001, 20000),
       (7, 20001, 25000),
       (8, 25001, 30000);
```
* 多表查询例子：
```SQL
SELECT * FROM EMP,dept; --笛卡尔积
```
![image](https://github.com/user-attachments/assets/457e8792-5e4d-46fb-bbbf-94a2ff955cd5)

* 消除无效的笛卡尔积：
```sql
SELECT * FROM emp,dept where emp.dept_id = dept.id ORDER BY emp.id asc;
```
![image](https://github.com/user-attachments/assets/c0408858-3ec3-42f6-924f-ef31ed3697bb)

## 多表查询分类
* 连接查询
* 内连接：相当于查询A、B交集部分数据
* 外连接：
   * 左外连接:查询**左表**所有数据，以及两张表交集部分数据
   * 右外连接:查询**右表**所有数据，以及两张表交集部分数据
* 自连接:当前表与自身的连接查询，**自连接必须使用表别名**


### 内连接
* 隐式内连接：
```SQL
SELECT 字段列表 FROM 表1,表2 WHERE 条件...;
```
* 显式内连接:
```SQL
SELECT 字段列表 FROM 表1 [INNER] JOIN 表2 ON 连接条件...;
```
* 内连接查询的是两张表交集的部分
* 例如：查询每一个员工的姓名，及关联的部门的名称(隐式内连接实现)
```sql
SELECT emp.name , dept.name from emp, dept where emp.dept_id = dept.id ;
SELECT e.name , d.name from emp e , dept d where e.dept_id = d.id; --为表结构取别名
```

* 例如：查询每一个员工的姓名，及关联的部门的名称(显式内连接实现)
```sql
SELECT e.name, d.name from emp e inner join dept d on e.dept_id = d.id;
SELECT e.name as '姓名', d.name as '部门' from emp e inner join dept d on e.dept_id = d.id;
```
![image](https://github.com/user-attachments/assets/d92a8775-93c3-4b22-b141-f3eb6c267753)

### 外连接
* 左外连接
```SQL
SELECT 字段列表 FROM 表1 LEFT [OUTER] JOIN 表2 ON 条件 ...;
-- 相当于查询表1(左表)的所有数据 包含 表1和表2交集部分的数据
```
![image](https://github.com/user-attachments/assets/e8623533-89b8-40b1-9094-5d315f839d5b)


* 右外连接
```SQL
SELECT 字段列表 FROM 表1 RIGHT [OUTER] JOIN 表2 ON 条件 ...;
-- 相当于查询表2(右表)的所有数据 包含 表1和表2交集部分的数据
```

* 例如：查询emp表的所有数据，和对应的部门信息-左外连接(有一个ID没有对应的链接数据,因此内连接无法使用)
```SQL
SELECT e.* , d.name FROM emp e left outer join dept d on e.dept_id = d.id;
```
![image](https://github.com/user-attachments/assets/2787bfe7-f143-4d5c-a40c-fe71db0e79d7)

* 可以看到,即使17号陈友凉没有部门信息,通过**左外连接**依然将其包含

* 例如：查询dept表的所有数据，和对应的员工信息(右外连接)
```sql
SELECT d.* , e.* FROM emp e right  outer join dept d on e.dept_id = d.id;
```

![image](https://github.com/user-attachments/assets/fd304df6-dd1b-4100-bacd-db106fa58f27)


### 自连接
```SQL
SELECT 字段列表 FROM 表A 别名A JOIN 表A 别名B ON 条件...;
```
* 自连接查询，可以是内连接查询，也可以是外连接查询

* 例如：查询员工 及其 所属领导的名字
![image](https://github.com/user-attachments/assets/a2f097d5-2c5a-49e1-9d8c-14e3b03ed860)

* 员工同时是领导、领导同时也是员工，这样就构成了两张表：
![image](https://github.com/user-attachments/assets/717042b7-bb33-4479-83c7-6a0a5353d8ab)

```SQL
SELECT a.name , b.name from emp a , emp b where a.managerid = b.id;
-- 表必须起别名！
```
![image](https://github.com/user-attachments/assets/ee398164-1af1-405d-b8de-452a0ab4ab88)

* 查询所有员工 emp 及其领导的名字 emp，如果员工没有领导，也需要查询出来(外连接)
```sql
SELECT a.name '员工' , b.name '领导' FROM emp a left join emp b on a.managerid = b.id;
```
![image](https://github.com/user-attachments/assets/25a5ea2b-2ec0-4691-a901-c126e19006ff)


## 联合查询
* 对于union查询，就是把多次查询的结果合并起来，形成一个新的查询结果集
```SQL
SELECT 字段列表 FROM 表A ...;
UNION [ALL]
SELECT 字段列表 FROM 表B ...;
```

* 例如：将薪资低于 5000 的员工，和年龄大于 50 岁的员工全部査询出来
```
SELECT * FROM emp where salary < 5000;
UNION
-- UNION自动去重 , Union all 直接将两张表连接
SELECT * from emp where age > 50;
```
![image](https://github.com/user-attachments/assets/b2824659-1660-4175-afd8-9b5d8d3502a8)

* 注意：
   * **对于联合查询的多张表的列数必须保持一致，字段类型也需要保持一致**
   * union all 会将全部的数据直接合并在一起，union 会对合并之后的数据去重。

## 子查询
* SQL语句中嵌套SELECT语句，称为嵌套查询，又称子查询
```SQL
SELECT * FROM t1 WHERE column1= (SELECT column1 FROM t2 );
```
* **子查询外部的语句可以是INSERT/UPDATE/DELETE/SELECT的任何一个**

* 根据子查询结果不同，分为:
   * 标量子查询(子查询结果为单个值)
   * 列子查询(子查询结果为一列)
   * 行子查询(子查询结果为一行)
   * 表子查询(子查询结果为多行多列)
 
* 根据子查询位置，分为:WHERE之后、FROM之后、SELECT之后

### 标量子查询
* **子查询返回的结果是单个值(数字、字符串、日期等)，最简单的形式**，这种子查询是标量子查询
   * 常用的操作符:= <> > >= < <=
 
* 例如：查询“销售部”的所有员工信息
```SQL
SELECT * FROM emp WHERE dept_id = (SELECT id from dept where name = '销售部');
```
![image](https://github.com/user-attachments/assets/8e5f8b24-8d27-4195-85b3-0c131abcda58)

* 例如：查询在“方东白”入职之后的员工信息
```SQL
SELECT * FROM emp WHERE entrydate > (SELECT entrydate from emp WHERE name = '方东白');
```
### 列子查询
* **子查询返回的结果是一列(可以是多行)**，这种子查询称为列子查询
* **常用的操作符:IN、NOT IN、ANY、SOME、ALL**
![image](https://github.com/user-attachments/assets/01bc793d-9bef-4414-a8d6-c5127c079b38)

* 例如：查询'销售部'和'市场部'的所有员工信息
```sql
SELECT * FROM emp WHERE dept_id in (SELECT id from dept where name = '销售部' or name = '市场部');
```

* 例如：查询比财务部所有人工资都高的员工数据：
```SQL
SELECT * from emp where salary > all(SELECT salary from emp where dept_id = (select id from dept where name = '财务部'));
-- 这里不能用max(),因为where后不能带聚合函数.
```
![image](https://github.com/user-attachments/assets/81dab113-b8bb-45b3-bbbf-14f81d4864c7)

* 例如,查询比研发部任意一人工资都高的员工信息
```SQL
SELECT * from emp where salary > ANY (SELECT salary from emp where dept_id = (select id from dept where name = '研发部'));
```

### 行子查询
* **子查询返回的结果是一行(可以是多列)**，这种子查询称为行子查询
* **常用操作符：= <> IN 、 NOT IN**

* 例如：查询与“张无忌”的薪资及直属领导相同的员工信息
```SQL
-- 首先:
select salary,managerid from emp where name ='张无忌;
```
![QQ_1721203951516](https://github.com/user-attachments/assets/2d4e278d-80db-4597-8893-6f53b8ec688a)

* 接下来有:
```SQL
select * from emp where(salary,managerid)=(12500,1);
```
* 即：
```
SELECT * from emp where (salary,managerid) = (SELECT salary,managerid from emp where name = '张无忌');
```
![image](https://github.com/user-attachments/assets/a7428396-70ec-4ad5-94c9-3e37983abfec)

* 行子查询，指的是子查询返回的值```(SELECT salary,managerid from emp where name = '张无忌');```是一行多列的

### 表子查询
* **子查询返回的结果是多行多列，这种子查询称为表子查询**
   * **常用的操作符:IN**

* 例如：查询与“鹿杖客",“宋远桥”的职位和薪资相同的员工信息
```SQL
SELECT * from emp where (job,salary) in (SELECT job , salary from emp where name = '鹿杖客' or name  = '宋远桥');
-- IN 表示只要满足其中一项即可
```
![image](https://github.com/user-attachments/assets/fc84f6c4-e059-44ae-acca-083e3c650290)

* 例如：查询入职日期是“2006-01-01”之后的员工信息及其部门信息.
```SQL
-- 首先查询入职日期符合的员工
select * from emp where entrydate>'2006-01-01';

-- 再查询这部分员工对应的部门信息
select e.* , d.* from (select * from emp where entrydate>'2006-01-01') e left join dept d on e.dept_id = d.id;
```
![image](https://github.com/user-attachments/assets/23d22302-a053-4a82-9f92-7bafbdefbee7)

* **表子查询作为一张临时的表,再from之后,相当于构建出一张新表来查询**


## 多表查询练习
* 首先建立一张salgrade表:
```SQL
create table salgrade(
	grade int,
	losal int,
	hisal int
) comment '薪资等级表';

insert into salgrade values(1,0,3000);
insert into salgrade values(2,3001,5000);
insert into salgrade values(3,5001,8000);
insert into salgrade valves(4,8001,10000);
insert into salgrade valves(5,10001,15000);
insert into salgrade values(6,15001,20000);
insert into salgrade values(7,20001,25000);
insert into salgrade valves(8,25001,30000);
```

* 1、查询员工的姓名、年龄、职位、部门信息、(隐式内连接)
```SQL
SELECT e.name, e.age , e.job, d.name from emp e , dept d where e.dept_id = d.id;
```

* 2、查询年龄小于30岁的员工的姓名、年龄、职位、部门信息(显式内连接)
```SQL
SELECT e.name , e.age , e.job, d.name FROM emp e inner join dept d on e.dept_id = d.id where e.age < 30;
```

* 3、查询拥有员工的部门ID、部门名称
```SQL
SELECT DISTINCT d.id , d.name  FROM emp e , dept d where e.dept_id = d.id  ;
```

* 4、查询所有年龄大于40岁的员工，及其归属的部门名称;如果员工没有分配部门，也需要展示出来
```SQL
SELECT e.name , d.name from emp e left outer join dept d on e.dept_id = d.id where e.age > 40 ;
```

* 5、查询所有员工的工资等级

```sql
-- 连接条件:emp.salary >= salgrade.losal and emg.salary <= salgrade.hisal
SELECT e.*,s.grade,s.losal,s.hisal from emp e, salgrade	 s where e.salary >= s.losal and e.salary <= S.hisal;
-- 或者：
SELECT e.*,s.grade,s.losal,s.hisal from emp e, salgrade	s where e.salary BETWEEN s.losal and s.hisal;
```
![image](https://github.com/user-attachments/assets/6269727f-35e2-4441-bf9a-1ed1a632871a)


* 6、查询“研发部”所有员工的信息及 工资等级
```SQL
-- me:
	SELECT e.*, s.grade FROM emp e , salgrade s where e.salary BETWEEN s.losal and s.hisal and e.dept_id = (SELECT id from dept where name = '研发部');
-- from 三张表:
	SELECT e.* , s.grade from emp e ,dept d ,salgrade s where e.dept_id = d.id and (e.salary BETWEEN s.losal and s.hisal) and d.name = '研发部';
```

* 7、查询“研发部”员工的平均工资
```SQL
SELECT avg(e.salary) from emp e where dept_id = (SELECT id from dept where name = '研发部');
-- 隐式内连接：
select avg(e.salary)from emp e, dept d where e.dept id = d.id and d.name ='硏发部';
```

* 8、查询工资比'灭绝'高的员工信息
```
-- 标量子查询
SELECT * from emp  where salary > (SELECT salary from emp where name = '灭绝');
```

* 9、查询比平均薪资高的员工信息
```sql
SELECT * FROM emp where salary > (SELECT avg(salary) from emp);
-- 注意,这里的 聚合函数avg() 并没有直接放在where后面
```
